@page "/"
@namespace HopLind.OpenAIUI.Pages
@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers
@{
    Layout = "_Layout";
}

<component type="typeof(App)" render-mode="ServerPrerendered" />

<script language="javascript">
    const GLOBAL = {
        DotNetReference: null
    }

    function SetDotnetReference(pDotNetReference) {
        GLOBAL.DotNetReference = pDotNetReference
    }

    const SpeechRecognition = window.SpeechRecognition || webkitSpeechRecognition
    const SpeechSynthesis = speechSynthesis
    document.addEventListener("DOMContentLoaded", (event) => {
        setTimeout(checkAccessibility, 1000)

        setTimeout(renderMarkdownTimer, 3000)
    })

    let currentCharIndex = 0;

    function afterRenderCompletion() {
        if (GLOBAL.DotNetReference != null)
            GLOBAL.DotNetReference.invokeMethodAsync("UpdateChatRenderStatus", 0)

        setTimeout(renderMarkdownTimer, 3000)
    }

    function renderNextChar() {
        const markdownRaw = document.querySelector(".markdown-raw")
        if (markdownRaw == null) {
            afterRenderCompletion()

            return
        }

        const markdownContainer = document.querySelector(".markdown-container")

        const currentText = markdownRaw.textContent.slice(0, currentCharIndex)
        markdownContainer.innerHTML = marked.parse(currentText + "■")
        currentCharIndex++

        if (currentCharIndex <= markdownRaw.textContent.length) {
            const delayMax = 50
            const delay = Math.random() * delayMax

            markdownContainer.querySelectorAll("code").forEach((el) => hljs.highlightElement(el))
            setTimeout(renderNextChar, delay)
        }
        else {
            const markdownParent = markdownRaw.parentElement
            markdownParent.innerHTML = markdownContainer.innerHTML.replace(/■/, "")

            if (SpeechSynthesis) {
                let speakElement = document.createElement("button")
                markdownParent.previousElementSibling.appendChild(speakElement)
                speakElement = markdownParent.previousElementSibling.lastElementChild
                speakElement.outerHTML = '<button class="btn" onclick="speak(this)"><i class="fa-solid fa-volume-high"></i></button>'
            }

            hljs.highlightAll()

            afterRenderCompletion()

            const chatList = document.querySelector("#markdown-is-rendering").parentNode.querySelector("ul")
            chatList.scrollTop = chatList.scrollHeight
        }
    }

    function renderMarkdownTimer() {
        currentCharIndex = 0
        renderNextChar()
    }

    function populateVoiceList() {
        if (!SpeechSynthesis) return

        voices = SpeechSynthesis.getVoices().sort(function (a, b) {
            const aname = a.name.toUpperCase()
            const bname = b.name.toUpperCase()

            if (aname < bname)
                return -1
            else if (aname == bname)
                return 0
            else
                return +1
        })
    }

    function renderVoiceList() {
        if (voices.length == 0) populateVoiceList()

        const voiceSelect = document.querySelector("#voices")
        voiceSelect.innerHTML = ""

        let options = [];
        for (let i = 0; i < voices.length; i++) {
            const option = document.createElement("option")
            option.textContent = `${voices[i].name} (${voices[i].lang})`

            if (voices[i].default) {
                option.textContent += " -- DEFAULT"
                option.selected = true
            }

            option.setAttribute("data-lang", voices[i].lang)
            option.setAttribute("data-name", voices[i].name)
            options.push(option)
        }
        options.sort((a, b) => {
            const aAttr = a.dataset.lang
            const bAttr = b.dataset.lang
            if (aAttr < bAttr)
                return -1
            else if (aAttr > bAttr)
                return 1
            else
                return 0
        })
        if (!options.some((o) => o.selected)) {
            const defaultOption = options.find((o) => o.dataset.lang == navigator.language)
            defaultOption.selected = true
        }
        options.forEach((option) => voiceSelect.appendChild(option))
    }

    function checkAccessibility() {
        console.log("checkAccessibility: SpeechRecognition=" + (SpeechRecognition != null) + ", SpeechSynthesis=" + (SpeechSynthesis != null))

        if (SpeechSynthesis) {
            populateVoiceList()
            if (SpeechSynthesis.onvoiceschanged !== undefined)
                SpeechSynthesis.onvoiceschanged = populateVoiceList;
        }
    }

    function getAccessibility(Accessibility) {
        switch (Accessibility) {
            case "SpeechRecognition": return SpeechRecognition != null
            case "SpeechSynthesis": return SpeechSynthesis != null
        }
    }

    function startRecognition(voiceInputId) {
        const recognition = new SpeechRecognition()
        recognition.lang = navigator.language || navigator.userLanguage
        recognition.interimResults = true;
        recognition.maxAlternatives = 1;

        recognition.onresult = function (event) {
            const result = event.results[event.results.length - 1][0].transcript
            document.querySelector("#" + voiceInputId).value = result
            if (GLOBAL.DotNetReference != null)
                GLOBAL.DotNetReference.invokeMethodAsync("RefreshStatus", result)
        }
        recognition.onnomatch = function (event) {
            console.log("Cannot recognize any from voice input")
        }
        recognition.onerror = function (event) {
            console.log("Error occurred in recognition: " + event.error)
        }
        recognition.start();
    }

    let voices = [];
    function toggleAdvancedSettings(sender) {
        const advancedSettings = document.querySelector("#advancedSettings")

        advancedSettings.dataset.display = advancedSettings.dataset.display == 1 ? 0 : 1
        advancedSettings.style = advancedSettings.dataset.display == 1 ? "" : "display: none"
        sender.innerHTML = "<i class=\"fa-regular fa-lg fa-square-caret-" + (advancedSettings.dataset.display == 1 ? "up" : "down") + "\"></i>"
        sender.title = advancedSettings.dataset.display == 1 ? "Hide" : "Show"
    }

    function speak(sender) {
        if (!SpeechSynthesis) return

        if (SpeechSynthesis.speaking) {
            stopSpeaking()

            return
        }

        const voiceSelect = document.querySelector("#voices")

        // get text content except code nodes
        let textToSpeechNode = sender.parentElement.nextElementSibling.cloneNode(true)
        const codeNodes = textToSpeechNode.querySelectorAll("code")
        for (let i = 0; i < codeNodes.length; i++)
            codeNodes[i].parentElement.removeChild(codeNodes[i])

        const textToSpeech = textToSpeechNode.textContent
        textToSpeechNode = null

        const utterThis = new SpeechSynthesisUtterance(textToSpeech)

        utterThis.onend = function (event) {
            console.log("SpeechSynthesisUtterance.onend")
            document.querySelector(".fa-fade").className = document.querySelector(".fa-fade").className.replace(/\sfa\-fade/, "")
        };

        utterThis.onerror = function (event) {
            console.error("SpeechSynthesisUtterance.onerror")
        };

        const selectedOption = voiceSelect.selectedOptions[0].dataset.name
        for (let i = 0; i < voices.length; i++)
            if (voices[i].name === selectedOption) {
                utterThis.voice = voices[i]
                break
            }

        utterThis.rate = document.querySelector("#rate").value
        SpeechSynthesis.speak(utterThis);

        sender.querySelector("i").className = sender.querySelector("i").className + " fa-fade"
    }

    function stopSpeaking() {
        if (SpeechSynthesis.speaking) {
            SpeechSynthesis.cancel()

            document.querySelector(".fa-fade").className = document.querySelector(".fa-fade").className.replace(/\sfa\-fade/, "")
        }
    }
</script>

